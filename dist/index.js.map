{
  "version": 3,
  "sources": ["../src/lib/token.ts", "../src/lib/concept.ts", "../src/lib/util.ts", "../src/lang/token-kinds.ts", "../src/lang/ast/parser-state.ts", "../src/lang/ast/index.ts", "../src/lib/operators.ts", "../src/lang/parser.ts", "../src/lib/pattern.ts"],
  "sourcesContent": ["export interface Token {\n  loc: SourceLocation;\n  kind: TokenKind;\n}\n\nexport interface TokenKind {\n  name: string;\n  match: (input: string) => string | null | undefined;\n}\n\nexport interface SourceLocation {\n  source: string | null;\n  start: Position;\n  end: Position;\n}\n\nexport interface Position {\n  line: number;\n  column: number;\n  offset: number;\n}\n\nexport const tokenize = (source: string, tokenKinds: TokenKind[]) => {\n  const tokens: Token[] = [];\n\n  let start: Position = {\n    offset: 0,\n    line: 1,\n    column: 1,\n  };\n\n  const matchToken = (input: string): Token | null => {\n    for (const kind of tokenKinds) {\n      const matchedStr: string | null | undefined = kind.match(input);\n\n      if (matchedStr) {\n        const lines = matchedStr.split('\\n');\n\n        const end: Position = {\n          offset: start.offset + matchedStr.length,\n          line: start.line + lines.length - 1,\n          column:\n            lines.length > 0\n              ? lines.slice(-1)[0].length\n              : start.column + matchedStr.length,\n        };\n\n        return {\n          kind,\n          loc: {\n            start,\n            end,\n            source: matchedStr,\n          },\n        };\n      }\n    }\n\n    return null;\n  };\n\n  let sub: string = source;\n\n  while (sub.length > 0) {\n    const token = matchToken(sub);\n\n    if (!token) {\n      throw new Error(\n        `Unknown input starting at line ${start.line}, column ${start.column}`,\n      );\n    }\n\n    tokens.push(token);\n    start = token.loc.end;\n    sub = sub.slice(token.loc.source.length);\n  }\n\n  return tokens;\n};\n\nexport const RegExpTokenKind = (name: string, pattern: RegExp): TokenKind => ({\n  name,\n  match: (input) => {\n    return (pattern.exec(input) || [])[0];\n  },\n});\n\nexport class TokenError extends Error {\n  token: Token;\n\n  constructor(original: Error | string, token: Token) {\n    const { line, column } = token.loc.start;\n    super(\n      `${\n        original instanceof Error ? original.message : 'message'\n      } (line ${line}, column ${column})`,\n    );\n    this.token = token;\n  }\n}\n", "export type ConceptSequence = Concept[];\n\nexport type ConceptShape = number | (number | ConceptShape)[];\n\nexport class Concept {\n  key: string;\n  parts: ConceptSequence;\n  shape: ConceptShape;\n\n  constructor(inputs: { key?: string; parts?: Concept[] }) {\n    let parts = inputs.parts || [];\n\n    if (parts.length === 1) {\n      parts = parts[0].parts;\n    }\n\n    const key =\n      parts.length > 0 ? Concept.join(parts as Concept[]) : inputs.key || '';\n\n    this.key = key;\n    this.parts = parts;\n    this.shape = Concept.computeShape(this);\n  }\n\n  static computeShape(concept: Concept): ConceptShape {\n    if (concept.parts.length === 0) {\n      return 0;\n    }\n\n    const subdims = concept.parts.map(Concept.computeShape);\n\n    if (subdims.every((dim) => dim === 0)) {\n      return subdims.length;\n    }\n\n    return subdims;\n  }\n\n  static createAtom(key: string): Concept {\n    return new Concept({ key });\n  }\n\n  static createCompound(\n    parts: (Concept | ConceptSequence | string)[],\n  ): Concept {\n    return new Concept({\n      parts: parts.map((part) => {\n        if (Array.isArray(part)) {\n          return Concept.createCompound(part);\n        }\n\n        if (part instanceof Concept) {\n          return part;\n        }\n\n        return Concept.createAtom(part);\n      }),\n    });\n  }\n\n  static join(parts: Concept[]): string {\n    return parts\n      .map((part) => (part.parts.length >= 2 ? `[${part.key}]` : part.key))\n      .join(' ');\n  }\n\n  toString() {\n    return this.key;\n  }\n}\n\nexport const NULL_CONCEPT = Concept.createAtom('');\n\nexport const filterUniqueConcepts = (concepts: Concept[]): Concept[] => {\n  const map = new Map<string, Concept>();\n  concepts.forEach((concept) => map.set(concept.key, concept));\n  return Array.from(map.values());\n};\n\nexport const getConceptsDeep = (topConcepts: Concept[]): Concept[] => {\n  const map = new Map<string, Concept>();\n\n  topConcepts.forEach((c) => {\n    map.set(c.key, c);\n    getConceptsDeep(c.parts).forEach((sub) => {\n      map.set(sub.key, sub);\n    });\n  });\n\n  return Array.from(map.values());\n};\n\nexport const isAtom = (concept: Concept): boolean => {\n  return concept.parts.length === 0;\n};\n\nexport const isVariable = (concept: Concept): boolean => {\n  return isAtom(concept) && concept.key[0] === '$';\n};\n\nexport const isPattern = (concept: Concept): boolean => {\n  return (\n    isCompound(concept) &&\n    concept.parts.some((part) => {\n      return isVariable(part) || isPattern(part);\n    })\n  );\n};\n\nexport const isCompound = (concept: Concept): boolean => {\n  return concept.parts.length > 1;\n};\n\nexport const isTextBlock = (concept: Concept): boolean => {\n  return concept.key.slice(0, 2) + concept.key.slice(-2) === '<<>>';\n};\n", "import { Concept } from '..';\n\nexport interface VisitorContext<T> {\n  item: T;\n  prev?: T;\n  next?: T;\n  prevAll: () => Generator<T, null>;\n  nextAll: () => Generator<T, null>;\n}\n\nexport const combine = <T = any>(left: T[][], right: T[][]): T[][] => {\n  if (left.length === 0) {\n    return right;\n  }\n\n  if (right.length === 0) {\n    return left;\n  }\n\n  return left.flatMap((l) => {\n    return right.map((r) => [...l, ...r]);\n  });\n};\n\nexport const visitEach = <T = any>(\n  items: T[],\n  visitor: (context: VisitorContext<T>) => any,\n) => {\n  items.forEach((item, i) => {\n    visitor({\n      item: items[i],\n      prev: items[i - 1],\n      next: items[i + 1],\n      prevAll: function* () {\n        for (let j = i - 1; j >= 0; j -= 1) {\n          yield items[j];\n        }\n\n        return null;\n      },\n      nextAll: function* () {\n        for (let j = i + 1; j < items.length; j += 1) {\n          yield items[j];\n        }\n\n        return null;\n      },\n    });\n  });\n};\n\nexport const isNullConcept = (concept: Concept): boolean => {\n  return concept.key === '';\n};\n\nexport const uniqBy = <T>(items: T[], comp: (item: T) => any): T[] => {\n  const map = new Map<any, T>();\n\n  items.forEach((item) => {\n    map.set(comp(item), item);\n  });\n\n  return Array.from(map.values());\n};\n", "import { RegExpTokenKind } from '../lib/token';\n\nexport const NewlineSeparatorKind = RegExpTokenKind(\n  'NewlineSeparator',\n  /^([ \\t]*\\n[ \\t]*)+/,\n);\n\nexport const WhitespaceKind = RegExpTokenKind('Whitespace', /^[ \\t]+/);\n\nexport const CurlyLeftKind = RegExpTokenKind('CurlyLeft', /^\\{/);\n\nexport const CurlyRightKind = RegExpTokenKind('CurlyRight', /^\\}/);\n\nexport const SquareLeftKind = RegExpTokenKind('SquareLeft', /^\\[/);\n\nexport const SquareRightKind = RegExpTokenKind('SquareRight', /^\\]/);\n\nexport const ParenLeftKind = RegExpTokenKind('ParenLeft', /^\\(/);\n\nexport const ParenRightKind = RegExpTokenKind('ParenRight', /^\\)/);\n\nexport const CommaKind = RegExpTokenKind('ParenRight', /^,/);\n\nexport const SemicolonKind = RegExpTokenKind('ParenRight', /^;/);\n\nexport const TextBlockKind = RegExpTokenKind('TextBlock', /^<<(.|\\n)+?>>/);\n\nexport const AtomKind = RegExpTokenKind('Atom', /^[^ \\n\\t\\{\\}\\[\\]\\(\\)\\,\\;]+/);\n", "import { Token, TokenError } from '../../lib/token';\nimport { AtomKind, TextBlockKind } from '../token-kinds';\nimport { Block, Root, Permutation, Atom, TextBlock } from './nodes';\n\nexport interface ASTParserContext {\n  parent?: ASTParserContext;\n  block: Block | Root;\n  permutation: Permutation;\n}\n\nexport class ASTParserState {\n  root: Root;\n  context: ASTParserContext;\n\n  constructor() {\n    const permutation: Permutation = {\n      type: 'Permutation',\n      children: [],\n    };\n\n    const root: Root = {\n      type: 'Root',\n      children: [permutation],\n    };\n\n    this.context = { permutation, block: root };\n    this.root = root;\n  }\n\n  end() {\n    let context = this.context;\n\n    while (context) {\n      this.terminatePermutation();\n      context = context.parent;\n    }\n\n    return this;\n  }\n\n  terminatePermutation() {\n    if (this.context.permutation.children.length === 0) {\n      this.context.block.children.pop();\n    }\n\n    return this;\n  }\n\n  consumeAtomToken(token: Token) {\n    if (token.kind !== AtomKind) {\n      throw new TokenError('Token must be an Atom', token);\n    }\n\n    const atom: Atom = {\n      token,\n      type: 'Atom',\n      text: token.loc.source,\n    };\n\n    this.context.permutation.children.push(atom);\n\n    return this;\n  }\n\n  consumeTextBlockToken(token: Token) {\n    if (token.kind !== TextBlockKind) {\n      throw new TokenError('Token must be a TextBlock', token);\n    }\n\n    const textBlock: TextBlock = {\n      token,\n      type: 'TextBlock',\n      text: token.loc.source,\n    };\n\n    this.context.permutation.children.push(textBlock);\n\n    return this;\n  }\n\n  nextPermutation() {\n    this.terminatePermutation();\n\n    const permutation: Permutation = {\n      type: 'Permutation',\n      children: [],\n    };\n\n    this.context.block.children.push(permutation);\n    this.context.permutation = permutation;\n\n    return this;\n  }\n\n  startPermutationBlock(type: Block['type']) {\n    const permutation: Permutation = {\n      type: 'Permutation',\n      children: [],\n    };\n\n    const block: Block = {\n      type,\n      children: [permutation],\n    };\n\n    this.context.permutation.children.push(block);\n\n    this.context = {\n      block,\n      permutation,\n      parent: this.context,\n    };\n\n    return this;\n  }\n\n  endPermutationBlock() {\n    const { parent } = this.context;\n\n    if (!parent) {\n      throw new Error('Unexpected block ending');\n    }\n\n    this.terminatePermutation();\n    this.context = this.context.parent;\n\n    return this;\n  }\n}\n", "import { Token, TokenError } from '../../lib/token';\nimport { visitEach } from '../../lib/util';\nimport { Root } from './nodes';\nimport { ASTParserState } from './parser-state';\n\nimport {\n  AtomKind,\n  CurlyLeftKind,\n  CurlyRightKind,\n  SquareLeftKind,\n  SquareRightKind,\n  ParenLeftKind,\n  ParenRightKind,\n  CommaKind,\n  SemicolonKind,\n  NewlineSeparatorKind,\n  TextBlockKind,\n} from '../token-kinds';\n\nexport const parseAST = (tokens: Token[]): Root => {\n  const state: ASTParserState = new ASTParserState();\n\n  visitEach<Token>(tokens, ({ item }) => {\n    try {\n      switch (item.kind) {\n        // Atoms and text blocks\n        case AtomKind:\n          state.consumeAtomToken(item);\n          break;\n\n        case TextBlockKind:\n          state.consumeTextBlockToken(item);\n          break;\n\n        // Permutation blocks\n        case CurlyLeftKind:\n          state.startPermutationBlock('PermutationBlock');\n          break;\n\n        case CurlyRightKind:\n          state.endPermutationBlock();\n          break;\n\n        // Embedded permutation blocks\n        case SquareLeftKind:\n          state.startPermutationBlock('EmbeddedPermutationBlock');\n          break;\n\n        case SquareRightKind:\n          state.endPermutationBlock();\n          break;\n\n        // Parenthetical permutation blocks\n        case ParenLeftKind:\n          state.startPermutationBlock('ParentheticalPermutationBlock');\n          break;\n\n        case ParenRightKind:\n          state.endPermutationBlock();\n          break;\n\n        // Permutation separators\n        case CommaKind:\n          state.nextPermutation();\n          break;\n\n        case SemicolonKind:\n          state.nextPermutation();\n          break;\n\n        case NewlineSeparatorKind:\n          state.nextPermutation();\n          break;\n\n        default:\n          break;\n      }\n    } catch (err) {\n      throw new TokenError(err, item);\n    }\n  });\n\n  return state.end().root;\n};\n", "import { isAtom, isCompound } from '..';\nimport { Concept } from './concept';\n\nexport const applyAmpersandOperator = (concept: Concept) => {\n  if (isAtom(concept)) {\n    return concept;\n  }\n\n  const [replacement, ...rest] = concept.parts;\n  let didApplyAmpersand = false;\n\n  const recurse = (part: Concept): Concept => {\n    if (isCompound(part)) {\n      return Concept.createCompound(part.parts.map(recurse));\n    }\n\n    if (part.key === '&') {\n      didApplyAmpersand = true;\n      return replacement;\n    }\n\n    return part;\n  };\n\n  const replacedRest = rest.map(recurse);\n\n  return didApplyAmpersand ? Concept.createCompound(replacedRest) : concept;\n};\n", "import { Token, tokenize } from '../lib/token';\nimport { Concept, filterUniqueConcepts, NULL_CONCEPT } from '../lib/concept';\nimport { parseAST } from './ast';\nimport * as tokenKinds from './token-kinds';\nimport { combine } from '../lib/util';\nimport { applyAmpersandOperator } from '../lib/operators';\n\nimport {\n  ASTNode,\n  Atom,\n  EmbeddedPermutationBlock,\n  ParentheticalPermutationBlock,\n  Permutation,\n  PermutationBlock,\n  Root,\n  TextBlock,\n} from './ast/nodes';\n\nexport interface ParseConceptsResult {\n  source: string;\n  tokens: Token[];\n  ast: Root;\n  tokenTree: TokenTree;\n  concepts: Concept[];\n}\n\nexport type TokenTree = (Token | TokenTree)[];\n\nexport const parseConcepts = (source: string | string[]): Concept[] => {\n  source = Array.isArray(source) ? source.join('\\n') : source;\n\n  const tokens = tokenize(source, Object.values(tokenKinds));\n  const ast = parseAST(tokens);\n  const tokenTree = astToTokenTree(ast);\n  const concepts = filterUniqueConcepts(tokenTree.map(tokenTreeToConcept));\n\n  return concepts;\n};\n\nexport const parseConcept = (source: string): Concept => {\n  return parseConcepts(source)[0] || NULL_CONCEPT;\n};\n\nexport type KeyOrConcept = string | Concept;\n\nexport type ConceptSetSource = string | Concept | (string | Concept)[];\n\nexport const toConcept = (keyOrConcept: KeyOrConcept): Concept => {\n  if (keyOrConcept instanceof Concept) {\n    return keyOrConcept;\n  }\n\n  return Concept.createAtom(keyOrConcept);\n};\n\nexport const toConcepts = (source: ConceptSetSource): Concept[] => {\n  if (Array.isArray(source)) {\n    return source.flatMap(toConcepts);\n  }\n\n  if (source instanceof Concept) {\n    return [source];\n  }\n\n  return parseConcepts(source);\n};\n\nexport const tokenTreeToConcept = (tokenTree: TokenTree): Concept | null => {\n  if (tokenTree.length === 0) {\n    return null;\n  }\n\n  const recurse = (branch: TokenTree) => {\n    const parts = branch\n      .map((branch) => {\n        return Array.isArray(branch)\n          ? recurse(branch)\n          : Concept.createAtom(branch.loc.source);\n      })\n      .filter(Boolean);\n\n    if (parts.length === 1) {\n      return parts[0];\n    }\n\n    return Concept.createCompound(parts);\n  };\n\n  const concept = recurse(tokenTree);\n\n  return applyAmpersandOperator(concept);\n};\n\nexport const astToTokenTree = (root: ASTNode): TokenTree => {\n  const emitted: TokenTree = [];\n\n  const recurse = (\n    node: ASTNode,\n    prevSubPerms: TokenTree[] = [],\n  ): TokenTree[] => {\n    switch (node.type) {\n      case 'Atom':\n        return [[(node as Atom).token]];\n\n      case 'TextBlock':\n        return [[(node as TextBlock).token]];\n\n      case 'Root': {\n        const root = node as Root;\n        return root.children.flatMap((child) => recurse(child, []));\n      }\n\n      case 'PermutationBlock': {\n        const block = node as PermutationBlock;\n        return block.children.flatMap((child) => recurse(child, []));\n      }\n\n      case 'ParentheticalPermutationBlock': {\n        const block = node as ParentheticalPermutationBlock;\n\n        block.children.forEach((child) => {\n          const combinations = combine(prevSubPerms, recurse(child));\n          emitted.push(...combinations);\n        });\n\n        return [];\n      }\n\n      case 'EmbeddedPermutationBlock': {\n        const block = node as EmbeddedPermutationBlock;\n\n        return block.children.flatMap((child) => {\n          return recurse(child, []).map((embed) => [embed]);\n        });\n      }\n\n      case 'Permutation': {\n        const permutation = node as Permutation;\n        let subPrefixes: TokenTree[] = [];\n        let prevSubPerms: TokenTree[] = [];\n\n        permutation.children.forEach((segment) => {\n          const subPerms = recurse(segment, prevSubPerms);\n\n          if (subPrefixes.length === 0) {\n            subPrefixes = subPerms;\n          } else if (subPerms.length > 0) {\n            subPrefixes = subPrefixes.flatMap((left) => {\n              return subPerms.map((right) => {\n                return [...left, ...right];\n              });\n            });\n          }\n\n          prevSubPerms = subPerms;\n        });\n\n        return subPrefixes;\n      }\n\n      default:\n        throw new Error('Unhandled AST node type: ' + node.type);\n    }\n  };\n\n  const recursed = recurse(root);\n\n  return [...recursed, ...emitted];\n};\n", "import { ConceptSetSource, parseConcept, toConcepts } from '../lang/parser';\nimport { Concept, isPattern, isVariable } from './concept';\nimport { uniqBy } from './util';\n\nexport interface Template<TVariable extends string> {\n  patterns: Concept[];\n  interpolate: (variables: VariableSourceDict<TVariable>) => Concept[];\n}\n\nexport const createTemplate = <TVariable extends string>(\n  source: ConceptSetSource,\n): Template<TVariable> => {\n  const patterns = toConcepts(source);\n  const interpolate = interpolateToConcepts.bind(null, patterns);\n\n  return {\n    patterns,\n    interpolate,\n  };\n};\n\nexport interface RuleMatch {\n  pattern: Concept;\n  concept: Concept;\n  variables: VariableDict;\n}\n\nexport interface RuleSetMatch {\n  ruleMatches: RuleMatch[];\n  variables: VariableDict;\n}\n\nexport interface VariableDict {\n  [key: string]: Concept;\n}\n\nexport type VariableSourceDict<TVariable extends string = string> = {\n  [key in TVariable]: ConceptSetSource;\n};\n\nexport const getPatternMatches = (\n  patterns: Concept[],\n  concepts: Concept[],\n): RuleMatch[] => {\n  const matches: RuleMatch[] = [];\n\n  patterns.forEach((pattern) => {\n    const size = pattern.parts.length;\n\n    concepts\n      .filter((concept) => {\n        return concept.parts.length === size && concept.key !== pattern.key;\n      })\n      .forEach((concept) => {\n        const variables = extractVariables(concept, pattern);\n\n        if (variables) {\n          matches.push({\n            pattern,\n            concept,\n            variables,\n          });\n        }\n      });\n  });\n\n  return matches;\n};\n\nexport const interpolate = (\n  pattern: string | Concept,\n  variables: VariableDict,\n): string => {\n  if (typeof pattern === 'string') {\n    return interpolate(parseConcept(pattern), variables);\n  }\n\n  return interpolateToConcept(pattern, variables).key;\n};\n\nexport const interpolateToConcept = (\n  pattern: Concept,\n  variables: VariableSourceDict,\n): Concept => {\n  if (isPattern(pattern)) {\n    return Concept.createCompound(\n      pattern.parts.map((part) => {\n        return interpolateToConcept(part, variables);\n      }),\n    );\n  } else if (variables[pattern.key]) {\n    return toConcepts(variables[pattern.key])[0];\n  } else {\n    return pattern;\n  }\n};\n\nexport const interpolateToConcepts = (\n  patternSource: ConceptSetSource,\n  variables: VariableSourceDict,\n): Concept[] => {\n  const patterns: Concept[] = toConcepts(patternSource);\n  const variableConceptDict: { [key: string]: Concept[] } = {};\n\n  Object.entries(variables).forEach(([key, source]) => {\n    variableConceptDict[key] = toConcepts(source);\n  });\n\n  const concepts = Object.entries(variableConceptDict).reduce(\n    (partials, [k, values]) => {\n      return values.flatMap((v) => {\n        return partials.map((partial) => {\n          return interpolateToConcept(partial, { [k]: v });\n        });\n      });\n    },\n    patterns,\n  );\n\n  return uniqBy(concepts, (c) => c.key);\n};\n\nexport const extractVariables = (\n  concept: Concept,\n  pattern: Concept,\n): null | VariableDict => {\n  const size = pattern.parts.length;\n\n  if (concept.parts.length !== size) {\n    return null;\n  }\n\n  const variables: VariableDict = {};\n\n  for (let i = 0; i < size; i += 1) {\n    const conceptPart = concept.parts[i];\n    const patternPart = pattern.parts[i];\n\n    if (isVariable(patternPart)) {\n      const variableKey = patternPart.key;\n      const existingVariable = variables[variableKey];\n\n      if (existingVariable && existingVariable.key !== conceptPart.key) {\n        return null;\n      }\n\n      variables[variableKey] = conceptPart;\n    } else if (isPattern(patternPart)) {\n      const subVariables = extractVariables(conceptPart, patternPart);\n\n      if (!subVariables) {\n        return null;\n      }\n\n      for (const [variableKey, variable] of Object.entries(subVariables)) {\n        const existingVariable = variables[variableKey];\n\n        if (existingVariable && existingVariable.key !== variable.key) {\n          return null;\n        }\n\n        variables[variableKey] = variable;\n      }\n    } else if (conceptPart.key !== patternPart.key) {\n      return null;\n    }\n  }\n\n  return variables;\n};\n\nexport const getPatternVariables = (...patterns: Concept[] | Concept[][]) => {\n  const map = new Map<string, Concept>();\n\n  patterns.flat().forEach((pattern) => {\n    if (isVariable(pattern)) {\n      map.set(pattern.key, pattern);\n    } else if (isPattern(pattern)) {\n      getPatternVariables(pattern.parts).forEach((variable) => {\n        map.set(variable.key, variable);\n      });\n    }\n  });\n\n  return Array.from(map.values());\n};\n"],
  "mappings": "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",
  "names": []
}
